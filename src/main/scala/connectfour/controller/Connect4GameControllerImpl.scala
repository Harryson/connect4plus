package connectfour.controller

import ai.MiniMax
import connectfour.events.DropCoinScalaSwingEvent
import connectfour.model._
import connectfour.util.observer.{IObserverWithArguments, ObservableWithArguments}
import controller.Move
import manager.{RedoManager, UndoManager}
import modelinterfaces.Player

import scala.swing.Reactor

class Connect4GameControllerImpl(player1Name: String = "Hugo", player2Name: String = "Boos")
  extends ObservableWithArguments
  with Connect4GameController
  with IObserverWithArguments
  with Reactor {

  val player1: Player = new Connect4Player(player1Name)
  val player2: Player = new Connect4Computer(player2Name)
  //TODO 3 x var
  override var gameField = new Connect4GameField(player1, player2)
  override var undoManager = new UndoManager
  override var redoManager = new RedoManager

  listenTo(dropCoinEventScala)

  reactions += {
    case e: DropCoinScalaSwingEvent =>
      if (getPlayerOnTurn == player2 && !gameIsOver)
        MiniMax.getNextMove(this).execute
  }

  // TODO: mal schauen ob man es noch braucht
  //  // computer opens this game
  if (gameField.getPlayerOnTurn == player2) {
    notifyObservers()
    dropCoinEventScala.dropCoin()
 }

  override def reset() {
    newGameEventScala.newGame()
  }

  override def undo() {
    undoManager.undoCommand(redoManager)
    undoEventScala.undo()
  }

  override def undoLastMove() {
    undoManager.undoCommand()
  }

  override def redo() {
    redoManager.redoCommand(undoManager)
    redoEventScala.redo()
  }

  override def getPlayers: (Player, Player) = (player1, player2)

  override def getPlayerAt(currentRow: Int, currentColumn: Int): Player = {
    gameField.gameField(currentColumn)(currentRow)
  }

  override def getPlayerOnTurn = gameField.getPlayerOnTurn

  override def getWinner = gameField.getWinner

  override def gameIsOver = getWinner != ""

  //TODO zwei verschieden drops einmal richtig und einmal test
  override def dropCoin(column: Int): Boolean = {
    val oldGameField = gameField.cloneGameField()
    val success = gameField.dropCoin(column)

    if (success) {
      dropCoinEventScala.dropCoin()
      undoManager.addCommand(
        () => gameField = oldGameField
      )
    }

    success
  }

  override def noMovePossible(player: Player): Boolean = {
    if (Connect4MoveEvaluator.noMovePossible(gameField, player)) {
      return true
    }
    false
  }

  override def getScore(player: Player): Int = {
    //Connect4MoveEvaluator.getScore(gameField, player)
    if (getWinner == player.toString) {
      1000000
    } else if (getWinner != "") {
      -1000000
    } else {
      0
    }
  }

  override def generatePossibleMoves(player: Player): Seq[Move] = Connect4MoveEvaluator.generatePossibleMoves(this, gameField, player)

  /**
   * This is useful, if you want transform Moves, generated by a cloned GameController, for the current controller
   * @return transformed Move for the current GameController.
   */
  override def transferMoveToCurrentController(move: Move): Move = {
    if (move.isInstanceOf[Connect4Move]) {
      val connect4Move = move.asInstanceOf[Connect4Move]
      new Connect4Move(this, connect4Move.column)
    } else {
      move
    }

  }

  /**
   * @return deep copy of controller. Observers are not copied!
   */
  override def cloneController: Connect4GameController = {
    val controller = new Connect4GameControllerImpl(player1.name, player2.name)
    controller.gameField = gameField.cloneGameField()
    controller.undoManager = new UndoManager

    controller
  }

  def getCopyOfGameField = {
    this.cloneController.asInstanceOf[Connect4GameController].gameField
  }

  override def update(arg: Any) {
    val columnToDrop = arg.asInstanceOf[Int]
    dropCoin(columnToDrop)
  }

}