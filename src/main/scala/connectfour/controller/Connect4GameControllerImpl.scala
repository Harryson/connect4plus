package connectfour.controller

import connectfour.model._
import connectfour.util.observer.{IObserverWithArguments, ObservableWithArguments}
import controller.GameController
import modelinterfaces.{Move, Player}
import undomanager.UndoManager

import scala.swing.event.Event

/**
 * Created by maharr on 23.12.15.
 */
case class DropCoinScalaSwingEvent() extends Event
case class NewGameScalaSwingEvent() extends Event
case class UndoScalaSwingEvent() extends Event
case class RedoScalaSwingEvent() extends Event

object Connect4GameControllerImpl {
  private val defaultUserName = "Hugo"
  private val computerName = "Computer"

  private var controller = new Connect4GameControllerImpl(defaultUserName)

  /**
   * Call always getCurrentInstance() to get the latest instance!
   * Don't hold instances in classes,  because they could be outdated!
   */
  def reset() = {
    getNewInstance(defaultUserName, computerName)
    controller.newGameEventScala.newGame()
  }

  /**
   * Call always getCurrentInstance() to get the latest instance!
   * Don't hold instances in classes,  because they could be outdated!
   */
  def getNewInstance(player1Name: String, player2Name: String = computerName): Connect4GameControllerImpl = {

    // Save old fields
    val dropCoinEventScala = controller.dropCoinEventScala
    val newGameEventScala = controller.newGameEventScala

    // add old fields to new instance
    controller = new Connect4GameControllerImpl(player1Name, player2Name)

    controller
  }

  /**
   * Call always this method to get the latest instance!
   * Don't hold instances in classes,  because they could be outdated!
   */
  def getCurrentInstance = controller
}

class Connect4GameControllerImpl(player1Name: String = Connect4GameControllerImpl.defaultUserName,
                                 player2Name: String = Connect4GameControllerImpl.computerName)
  extends ObservableWithArguments
  with Connect4GameController
  with IObserverWithArguments {
  println("Create Connect4GameControllerImpl")

  val player1: Player = new Connect4Player(player1Name)
  val player2: Player = new Connect4Computer(player2Name, this)

  override protected var gameField = new Connect4GameField(player1, player2)
  private val undoManager = new UndoManager

  // computer open this game
  if (gameField.getPlayerOnTurn == player2) {
    notifyObservers()
    dropCoinEventScala.dropCoin
  }

  override def getPlayers: (Player, Player) = (player1, player2)

  override def getPlayerAt(currentRow: Int, currentColumn: Int) = {
    gameField.gameField(currentColumn)(currentRow)
  }

  override def getPlayerOnTurn: Player = gameField.getPlayerOnTurn

  override def getWinner: String = gameField.getWinner

  override def gameIsOver = getWinner != ""

  override def dropCoin(column: Int): Boolean = {
    val oldGameField = gameField.cloneGameField()

    undoManager.addCommand(
      () => gameField = oldGameField
    )

    val success = gameField.dropCoin(column)
    dropCoinEventScala.dropCoin
    success
  }

  override def undoLastMove = undoManager.undoCommand

  override def noMovePossible(player: Player): Boolean = {
    if (Connect4MoveEvaluator.noMovePossible(gameField, player)) {
      return true
    }
    false
  }

  override def getScore(player: Player): Int = {
    //Connect4MoveEvaluator.getScore(gameField, player)
    if (getWinner == player.toString) {
      1000000
    } else if (getWinner != "") {
      -1000000
    } else {
      0
    }
  }

  override def generatePossibleMoves(player: Player): List[Move] = Connect4MoveEvaluator.generatePossibleMoves(this, gameField, player)

  /**
   * This is useful, if you want transform Moves, generated by a cloned GameController, for the current controller
   * @return transformed Move for the current GameController.
   */
  override def transferMoveToCurrentController(move: Move): Move = {
    val connect4Move = move.asInstanceOf[Connect4Move]
    new Connect4Move(this, connect4Move.column)
  }

  /**
   * @return deep copy of controller. Observers are not copied!
   */
  override def cloneController: GameController = {
    val controller = new Connect4GameControllerImpl(player1.name, player2.name)
    controller.gameField = gameField.cloneGameField()

    controller
  }

  override def update(arg: Any) {
    val columnToDrop = arg.asInstanceOf[Int]
    dropCoin(columnToDrop)
  }
}