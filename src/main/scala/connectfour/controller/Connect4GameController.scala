package connectfour.controller

import connectfour.model.{Connect4Computer, Connect4GameField, Connect4Move, Connect4MoveEvaluator, Connect4Player}
import connectfour.ui.gui.scala.swing.events.{DropCoinEvent, NewGameEvent}
import controller.GameController
import modelinterfaces.{Move, Player}
import undomanager.UndoManager

import scala.swing.event.Event

/**
  * User: Stefano Di Martino
  * Date: 25.01.14
  * Time: 15:54
  */

case class DropCoinScalaSwingEvent() extends Event

case class NewGameScalaSwingEvent() extends Event

object Connect4GameController {
  private val computerName = "Computer"
  private val defaultUserName = "Hugo"

  private var controller = new Connect4GameController(defaultUserName)

  /**
    * Call always getCurrentInstance() to get the latest instance!
    * Don't hold instances in classes,  because they could be outdated!
    */
  def reset() = {
    getNewInstance(controller.player1.name, controller.player2.name)
    controller.newGameEventScala.newGame()
  }

  /**
    * Call always getCurrentInstance() to get the latest instance!
    * Don't hold instances in classes,  because they could be outdated!
    */
  def getNewInstance(player1Name: String, player2Name: String = computerName): Connect4GameController = {

    // Save old fields
    val dropCoinEventScala = controller.dropCoinEventScala
    val newGameEventScala = controller.newGameEventScala

    // add old fields to new instance
    controller = new Connect4GameController(player1Name, player2Name, dropCoinEventScala, newGameEventScala)

    controller
  }

  /**
    * Call always this method to get the latest instance!
    * Don't hold instances in classes,  because they could be outdated!
    */
  def getCurrentInstance = controller
}

class Connect4GameController(player1Name: String, player2Name: String = Connect4GameController.computerName,
                             val dropCoinEventScala: DropCoinEvent = new DropCoinEvent,
                             val newGameEventScala: NewGameEvent = new NewGameEvent) extends GameController {
  val player1: Player = new Connect4Player(player1Name)
  val player2: Player = new Connect4Computer(player2Name, this)

  protected var gameField = new Connect4GameField(player1, player2)
  private val undoManager = new UndoManager

  // Game has started and computer is on turn
  if (gameField.getPlayerOnTurn == player2) {
    dropCoinEventScala.dropCoin()
  }

  override def getPlayers: (Player, Player) = (player1, player2)

  def getPlayerAt(currentRow: Int, currentColumn: Int) = {
    gameField.gameField(currentColumn)(currentRow)
  }

  override def getPlayerOnTurn: Player = gameField.getPlayerOnTurn

  override def getWinner: String = gameField.getWinner

  override def gameIsOver = getWinner != ""

  def dropCoin(column: Int): Boolean = {
    val oldGameField = gameField.cloneGameField()

    undoManager.addCommand(
      () => gameField = oldGameField
    )

    val success = gameField.dropCoin(column)
    dropCoinEventScala.dropCoin()
    success
  }

  override def undoLastMove = undoManager.undoCommand

  override def noMovePossible(player: Player): Boolean = {
    if (Connect4MoveEvaluator.noMovePossible(gameField, player)) {
      return true
    }
    false
  }

  override def getScore(player: Player): Int = {
    //Connect4MoveEvaluator.getScore(gameField, player)
    if (getWinner == player.toString) {
      1000000
    } else if (getWinner != "") {
      -1000000
    } else {
      0
    }
  }

  override def generatePossibleMoves(player: Player): List[Move] = Connect4MoveEvaluator.generatePossibleMoves(this, gameField, player)

  /**
    * This is useful, if you want transform Moves, generated by a cloned GameController, for the current controller
    * @return transformed Move for the current GameController.
    */
  override def transferMoveToCurrentController(move: Move): Move = {
    val connect4Move = move.asInstanceOf[Connect4Move]
    new Connect4Move(this, connect4Move.column)
  }

  /**
    * @return deep copy of controller. Observers are not copied!
    */
  override def cloneController: GameController = {
    val controller = new Connect4GameController(player1.name, player2.name)
    controller.gameField = gameField.cloneGameField()

    controller
  }
}