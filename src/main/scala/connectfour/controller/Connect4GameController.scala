package connectfour.controller

import connectfour.model.Connect4Computer
import connectfour.model.Connect4GameField
import connectfour.model.Connect4Move
import connectfour.model.Connect4MoveEvaluator
import connectfour.model.Connect4Player
import connectfour.util.observer.IObserverWithArguments
import connectfour.util.observer.ObservableWithArguments
import controller.GameController
import modelinterfaces.Move
import modelinterfaces.Player
import undomanager.UndoManager
import scala.swing.Publisher
import scala.swing.event.Event

/**
 * User: Stefano Di Martino
 * Date: 25.01.14
 * Time: 15:54
 */

case class DropCoinScalaSwingEvent() extends Event
case class NewGameScalaSwingEvent() extends Event

object Connect4GameController extends {
  private val computerName = "Computer"
  private val defaultUserName = "Hugo"
  
  private var controller = new Connect4GameController(defaultUserName)
  
  /**
   * Call always getCurrentInstance() to get the latest instance!
   * Don't hold instances in classes,  because they could be outdated!
   */
  def reset = {
    getNewInstance(controller.player1.name, controller.player2.name)
  }
  
  /**
   * Call always getCurrentInstance() to get the latest instance!
   * Don't hold instances in classes,  because they could be outdated!
   */
  def getNewInstance( player1Name: String, player2Name: String = computerName) = {
    // Alte Subscribers sichern
    val subscribers = controller.subscribers
    
    controller = new Connect4GameController(player1Name, player2Name)
    
    // Alte Subscribers hinzufÃ¼gen
    controller.addAllObservers(subscribers)
    controller
  }
  
  /**
   * Call always this method to get the latest instance!
   * Don't hold instances in classes,  because they could be outdated!
   */
  def getCurrentInstance = controller
}

class Connect4GameController(player1Name: String, player2Name: String = Connect4GameController.computerName) extends ObservableWithArguments with GameController with IObserverWithArguments {
  val player1: Player = new Connect4Player(player1Name)
  val player2: Player = {
    if (player2Name == Connect4GameController.computerName)
      new Connect4Computer(Connect4GameController.computerName, this, this)
    else
      new Connect4Player(player2Name)
  }
  protected var gameField = new Connect4GameField(player1, player2)
  private val undoManager = new UndoManager

  if (gameField.getPlayerOnTurn == player2) {
    notifyObservers()
  }

  override def getPlayers: (Player, Player) = (player1, player2)

  def getPlayerAt(currentRow: Int, currentColumn: Int) = {
    gameField.gameField(currentColumn)(currentRow)
  }

  override def getPlayerOnTurn: Player = gameField.getPlayerOnTurn

  override def getWinner: String = gameField.getWinner

  def dropCoin(column: Int) = {
    val oldGameField = gameField.cloneGameField

    undoManager.addCommand(
      () => gameField = oldGameField
    )

    val success = gameField.dropCoin(column)

    notifyObservers()
    success
  }

  override def undoLastMove = undoManager.undoCommand

  override def noMovePossible(player: Player): Boolean = {
    if (getWinner != "") {
      return true
    }
    if (Connect4MoveEvaluator.noMovePossible(gameField, player)) {
      return true
    }
    false
  }

  override def getScore(player: Player): Int = {
    //Connect4MoveEvaluator.getScore(gameField, player)
    if (getWinner == player.toString) {
      Int.MaxValue
    } else if (getWinner != "") {
      Int.MinValue
    } else {
      0
    }
  }

  override def generatePossibleMoves(player: Player): List[Move] = Connect4MoveEvaluator.generatePossibleMoves(this, gameField, player)

  /**
   * This is useful, if you want transform Moves, generated by a cloned GameController, for the current controller
   * @return transformed Move for the current GameController.
   */
  override def transformMoveFromClonedControllerForCurrentController(move: Move): Move = {
    val connect4Move = move.asInstanceOf[Connect4Move]
    new Connect4Move(this, connect4Move.column)
  }

  /**
   * @return deep copy of controller. Observers are not copied!
   */
  override def cloneController: GameController = {
    val controller = new Connect4GameController(player1.name, player2.name)
    controller.gameField = gameField.cloneGameField

    controller
  }

  override def update(arg: Any) {
    val columnToDrop = arg.asInstanceOf[Int]
    dropCoin(columnToDrop);
  }
}